## 变量
零值：
- 数值类型变量对应的零值是0
- 布尔类型变量对应的零值是false
- 字符串类型对应的零值是空字符串
- 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。
- 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

### var声明语句
```go
var 变量名字 类型 = 表达式
```
其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。

可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：
```go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```
### 简短变量声明
在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。

简短变量声明语句中必须至少要声明一个新的变量, 已存在变量则为正常的赋值，对新变量的位置没有要求
```go
i, j := 0, 1
i, j, k := 2, 3, 4
l, i, j, k := 5, 6, 7, 8
l, m, i, n, j, k := 9, 10, 11, 12, 13, 14
fmt.Println(i, j, k, l, m, n)
```

## 指针
任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，**只有当它们指向同一个变量或全部是nil时才相等**。

### new函数
另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。
```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
```
每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```
当然也可能有特殊情况：**如果两个类型都是空的，也就是说类型的大小是0，例如struct{}和[0]int，有可能有相同的地址（依赖具体的语言实现）**（译注：请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看runtime.SetFinalizer函数相关文档）。

### 变量的生命周期
变量的生命周期指的是在程序运行期间变量有效存在的时间段。**对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。**

那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它**是否存在并不会影响程序后续的计算结果**。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。
```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```
f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。

如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：
```go
v, ok = m[key]             // map lookup
v, ok = x.(T)              // type assertion
v, ok = <-ch               // channel receive

v = m[key]                // map查找，失败时返回零值
v = x.(T)                 // type断言，失败时panic异常
v = <-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）关闭了算是失败
```
> 如何得知变量是分配在栈（stack）上还是堆（heap）上？
<br><br>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。
<br>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。
<br>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。

函数返回值的使用与否也会影响变量是否会逃逸：
```go
package main

type Student struct {
	Name string
	Age  int
}

func StudentRegister(name string, age int) Student {
	s := Student{}

	s.Name = name
	s.Age = age

	return s
}

func main() {
  // 不逃逸：
	_ = StudentRegister("Jim", 18)

  // 逃逸：
	//s := StudentRegister("Jim", 18)
	//fmt.Println(s)
}

```